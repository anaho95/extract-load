#!/usr/bin/env python3

import sys
import argparse
import subprocess
import json
import getpass
import re
import datetime
import time
import tempfile
import os
import shutil


class UmEmr:
    def __init__(self, args):
        # Default config
        self.config = {
            "version": "1.0",
            "region": "us-west-2",
            "regions": ["us-west-1", "us-east-1", "us-west-2"],
            "display": {
                "columns": {
                    "Name": {
                        "min_width": 28,
                        "max_width": 60,
                    },
                    "Status": {
                        "min_width": 5,
                        "max_width": 20,
                    },
                    "Id": {
                        "min_width": 16,
                        "max_width": 16,
                        "show_full": True,
                    },
                    "Created": {
                        "min_width": 19,
                        "max_width": 22,
                    },
                    "Hours": {
                        "min_width": 5,
                        "max_width": 8,
                        "show_full": True,
                    },
                    "Mins": {
                        "min_width": 5,
                        "max_width": 8,
                        "show_full": True,
                    },
                },
                "clusters": ["Name", "Status", "Id", "Created", "Hours"],
                "steps": ["Name", "Status", "Id", "Created", "Mins"],
            },
            "fleets": {
                "default": [
                    {
                        "Name": "Masterfleet",
                        "InstanceFleetType": "MASTER",
                        "TargetSpotCapacity": 1,
                        "InstanceTypeConfigs": [{"InstanceType": "m3.xlarge"}],
                    },
                    {
                        "Name": "Corefleet",
                        "InstanceFleetType": "CORE",
                        "TargetSpotCapacity": 18,
                        "LaunchSpecifications": {
                            "SpotSpecification": {
                                "TimeoutDurationMinutes": 90,
                                "TimeoutAction": "SWITCH_TO_ON_DEMAND",
                            }
                        },
                        "InstanceTypeConfigs": [
                            {
                                "WeightedCapacity": 18,
                                "InstanceType": "c5d.18xlarge",
                                "BidPriceAsPercentageOfOnDemandPrice": 100,
                            },
                            {
                                "WeightedCapacity": 9,
                                "InstanceType": "c5d.9xlarge",
                                "BidPriceAsPercentageOfOnDemandPrice": 100,
                            },
                            {
                                "WeightedCapacity": 24,
                                "InstanceType": "m5d.24xlarge",
                                "BidPriceAsPercentageOfOnDemandPrice": 100,
                            },
                            {
                                "WeightedCapacity": 16,
                                "InstanceType": "m5d.16xlarge",
                                "BidPriceAsPercentageOfOnDemandPrice": 100,
                            },
                        ],
                    },
                ]
            },
        }

        self.config_file = os.path.join(
            os.path.expanduser("~"), ".emr-tools.conf"
        )

        # If a config file exists, read it in.
        if os.path.isfile(self.config_file):
            with open(self.config_file, "rt") as fh:
                self.config = json.load(fh)

        # Parse the command line args
        params, self.extra_args = self.find_params(args)

        self.cluster_id = params.get("cluster_id", None)
        self.step_id = params.get("step_id", None)
        self.region = params.get("region", self.config["region"])

        # Note if the region wasn't provided in the command line arguments
        # because the list_clusters() behavior is different in that case
        self.defaulted_region = "region" not in params

    def find_params(self, args):
        # Pattern match the command line args to see if they fit
        # any of the desired types

        patterns = {
            "region": r"\w{2}-\w{4}-\d$",
            "cluster_id": r"j-\w+$",
            "step_id": r"s-\w+$",
        }

        extra_args = []
        params = {}

        for arg in args:
            found = False
            for key, pattern in patterns.items():
                if re.match(pattern, arg):
                    params[key] = arg
                    found = True
                    break

            if not found:
                extra_args.append(arg)

        return params, extra_args

    def aws(self, params):
        try:
            output = subprocess.check_output(
                ["aws"] + ["--output"] + ["json"] + params
            )
        except FileNotFoundError:
            sys.exit("ERROR: aws-cli not found in path")

        return output.decode("utf-8")

    def build_format(self, columns):
        available_width = shutil.get_terminal_size((80, 25)).columns

        # subtract padding between columns
        pad = 1
        available_width -= len(columns) * pad

        # First allocate the minimum necessary widths
        widths = []
        min_total_width = 0
        max_total_width = 0
        for column in columns:
            w = self.config["display"]["columns"][column]
            widths.append(w["min_width"])

            min_total_width += w["min_width"]
            max_total_width += w["max_width"]

        if available_width > min_total_width:
            if available_width > max_total_width:
                # If sufficient space allocate full widths to columns
                for idx, column in enumerate(columns):
                    widths[idx] = self.config["display"]["columns"][column][
                        "max_width"
                    ]
            else:
                # If insufficient space, do a proportional allocation
                available_width -= min_total_width

                requested_width = max_total_width - min_total_width
                proportion = int(float(available_width) / float(len(columns)))

                for idx, column in enumerate(columns):
                    w = self.config["display"]["columns"][column]
                    requested_width = w["max_width"] - widths[idx]
                    added = min(requested_width, proportion)

                    widths[idx] += added
                    available_width -= added

                # There may be a few extra spaces left, so assign them
                # if possible
                for idx, column in enumerate(columns):
                    if available_width:
                        w = self.config["display"]["columns"][column]
                        requested_width = w["max_width"] - widths[idx]
                        added = min(requested_width, available_width)

                        widths[idx] += added
                        available_width -= added

        formatted_columns = []
        for idx, column in enumerate(columns):

            ## TODO: add support for text jutstify

            fmt = "{" + column + ":" + str(widths[idx])
            if not self.config["display"]["columns"][column].get("show_full"):
                fmt += "." + str(widths[idx])
            fmt += "}"

            formatted_columns.append(fmt)

        return (" " * pad).join(formatted_columns)

    def format_datetime(self, dt):
        if isinstance(dt, float) or re.match(r"\d+\.\d+", dt):
            return datetime.datetime.fromtimestamp(float(dt)).isoformat()

        return dt

    def list_clusters(self):

        if self.defaulted_region:
            regions = self.config["regions"]
        else:
            regions = [self.region]

        fmt = self.build_format(self.config["display"]["clusters"])

        params = ["emr", "list-clusters", "--active"]

        for region in regions:
            clusters = json.loads(self.aws(params + ["--region", region]))

            print("region: {region}".format(region=region))
            print(
                fmt.format(
                    Name="Name",
                    Status="Status",
                    Id="Id",
                    Created="Created",
                    Hours="Hours",
                )
            )
            for cluster in clusters["Clusters"]:
                print(
                    fmt.format(
                        Name=cluster["Name"],
                        Status=cluster["Status"]["State"],
                        Id=cluster["Id"],
                        Created=self.format_datetime(
                            cluster["Status"]["Timeline"]["CreationDateTime"]
                        ),
                        Hours=cluster["NormalizedInstanceHours"],
                    )
                )
            print("")

    def parse_datetime(self, dt):
        # If already in unixtime format, just return it cast as float

        if isinstance(dt, float):
            return dt
        elif re.match(r"\d+\.\d+", dt):
            return float(dt)

        return datetime.datetime.fromisoformat(dt).timestamp()

    def list_steps(self):
        params = [
            "--region",
            self.region,
            "emr",
            "list-steps",
            "--cluster-id",
            self.cluster_id,
        ]

        fmt = self.build_format(self.config["display"]["steps"])

        steps = json.loads(self.aws(params))

        print(
            fmt.format(
                Name="Name",
                Status="Status",
                Id="id",
                Created="Created",
                Mins="Mins",
            )
        )
        for step in steps["Steps"]:
            if "StartDateTime" in step["Status"]["Timeline"]:
                starttime = self.parse_datetime(
                    step["Status"]["Timeline"]["StartDateTime"]
                )

                if "EndDateTime" in step["Status"]["Timeline"]:
                    endtime = self.parse_datetime(
                        step["Status"]["Timeline"]["EndDateTime"]
                    )

                    duration = str(round(int(endtime - starttime) / 60.0, 1))
                else:
                    duration = "({})".format(
                        round(int(time.time() - starttime) / 60.0, 1)
                    )
            else:
                duration = "0"

            print(
                fmt.format(
                    Name=step["Name"],
                    Status=step["Status"]["State"],
                    Id=step["Id"],
                    Created=self.format_datetime(
                        step["Status"]["Timeline"]["CreationDateTime"]
                    ),
                    Mins=duration,
                )
            )

    def describe_step(self):
        params = [
            "--region",
            self.region,
            "emr",
            "describe-step",
            "--cluster-id",
            self.cluster_id,
            "--step-id",
            self.step_id,
        ]

        print(self.aws(params))

    def describe_cluster(self):

        params = [
            "--region",
            self.region,
            "emr",
            "describe-cluster",
            "--cluster-id",
            self.cluster_id,
        ]

        return self.aws(params)

    def cluster_master(self):
        cluster = json.loads(self.describe_cluster())

        return cluster["Cluster"]["MasterPublicDnsName"]

    def terminate_cluster(self):

        params = [
            "--region",
            self.region,
            "emr",
            "terminate-clusters",
            "--cluster-id",
            self.cluster_id,
        ]

        print(self.aws(params))

    def ssh_cluster(self, identity_file=None, socks=False):
        args = ["ssh"]

        if identity_file is not None:
            args.extend(["-i", identity_file])

        if socks:
            args.extend(["-D", "8157", "-N"])

        args.append("hadoop@{}".format(self.cluster_master()))

        os.execvp("ssh", args)

    def socks_cluster(self, identity_file=None):
        print(self.cluster_master())
        self.ssh_cluster(identity_file=identity_file, socks=True)

    def create_cluster(self):
        cluster_config = {
            "cluster_name": getpass.getuser() + "-dev",
            "cluster_capacity": "18",
            "release_label": "emr-6.2.0",
            "cost_center": "per-" + getpass.getuser(),
            "region": self.region,
        }

        for key, default in cluster_config.items():
            value = input(
                "{key} [{default}]: ".format(key=key, default=default)
            )
            if value:
                cluster_config[key] = value

        if self.region == "us-west-1":
            cluster_config["keyname"] = "uberads.us-west-1.elasticmapreduce"
            cluster_config["subents"] = "[subnet-6bf7b60f,subnet-d311828b]"
        elif self.region == "us-west-2":
            cluster_config["keyname"] = "uberads.us-west-2.elasticmapreduce"
            cluster_config[
                "subnets"
            ] = "[subnet-06f0fa64,subnet-3dbe8b49,subnet-bc95c2fa]"
        else:
            raise NameError(
                "create_cluster() region '{}', not supported".format(
                    self.region
                )
            )

        fleet = self.config["fleets"]["default"].copy()
        fleet[1]["TargetSpotCapacity"] = int(
            cluster_config["cluster_capacity"]
        )

        tf = tempfile.NamedTemporaryFile("wt")
        json.dump(fleet, tf)
        tf.flush()

        params = [
            "--region",
            self.region,
            "emr",
            "create-cluster",
            "--name",
            cluster_config["cluster_name"],
            "--release-label",
            cluster_config["release_label"],
            "--service-role",
            "EMR_DefaultRole",
            "--no-auto-terminate",
            "--instance-fleets",
            "file://{}".format(tf.name),
            "--tags",
            "CostCenter={}".format(cluster_config["cost_center"]),
            "--applications",
            "Name=Ganglia",
            "Name=Spark",
            "Name=Zeppelin",
            "Name=Livy",
            "Name=JupyterEnterpriseGateway",
            "Name=JupyterHub",
            "--log-uri",
            "s3://uberads-emr/logs-jobflows/",
            "--ec2-attributes",
            "KeyName={keyname},InstanceProfile=EC2_EMR_Firehose,SubnetIds={subnets}".format(
                keyname=cluster_config["keyname"],
                subnets=cluster_config["subnets"],
            ),
            "--visible-to-all-users",
        ]

        print(self.aws(params))

    def write_config(self):
        if not os.path.isfile(self.config_file):
            with open(self.config_file, "wt") as ofh:
                json.dump(self.config, ofh, indent=2)
                ofh.write("\n")
            print(
                "Configuration file written. conf={}".format(self.config_file)
            )


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "command",
        help="Command",
        type=str,
        choices=[
            "config",
            "clusters",
            "create",
            "describe",
            "master",
            "socks",
            "ssh",
            "steps",
            "terminate",
        ],
    )
    parser.add_argument("params", help="Parameters", type=str, nargs="*")
    parser.add_argument("--region", help="Region", type=str)
    parser.add_argument(
        "-i", "--identity-file", help="SSH identity file", type=str
    )

    args = parser.parse_args()

    return args


def main():
    args = parse_args()

    ue = UmEmr(args.params)

    if args.command == "clusters":
        ue.list_clusters()
    elif args.command == "steps":
        if ue.step_id:
            ue.describe_step()
        else:
            ue.list_steps()
    elif args.command == "describe":
        print(ue.describe_cluster())
    elif args.command == "master":
        print(ue.cluster_master())
    elif args.command == "terminate":
        ue.terminate_cluster()
    elif args.command == "ssh":
        ue.ssh_cluster(args.identity_file)
    elif args.command == "socks":
        ue.socks_cluster(args.identity_file)
    elif args.command == "create":
        ue.create_cluster()
    elif args.command == "config":
        ue.write_config()


if __name__ == "__main__":
    main()
    sys.exit(0)
